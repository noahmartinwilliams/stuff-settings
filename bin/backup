#! /bin/bash

YES=0
REMOTE=0
ON_DONE_COMMAND="exit 0"
ON_ERROR_COMMAND="exit 1"
EXCLUDE=""
RSYNC_OPTS="-rluvH --no-inc-recursive --modify-window=1"
SYNC='flock $(catpath $(catpath $DEST $(hostname)) $SRC) -c "rsync $RSYNC_OPTS $EXCLUDE $SRC/ $(catpath $(catpath $(catpath $DEST $(hostname)) $SRC) $TODAY)/"'
SYNCLINKDEST='flock $(catpath $(catpath $DEST $(hostname)) $SRC) -c "rsync $RSYNC_OPTS $EXCLUDE --link-dest=$LATEST $SRC/ $(catpath $(catpath $(catpath $DEST $(hostname)) $SRC) $TODAY)/"'
function catpath {
	P=$1
	if [[ "$P" = */ ]];
	then
		if [[ "$2" = /* ]];
		then
			echo "$1${2#*/}"
		else
			echo "$1$2"
		fi
	else
		if [[ "$2" = /* ]];
		then
			echo "$1$2"
		else
			echo "$1/$2"
		fi
	fi
}

PRESERVE_TIMES=1
while getopts ":ri:u:d:s:yc:e:C" COM_OPT;
do
	case $COM_OPT in
		y)
			YES=1
			shift;
			;;
		r)
			REMOTE=1
			SYNC='rsync -e ssh $RSYNC_OPTS $EXCLUDE $SRC/ $(catpath $(catpath $(catpath $USER@$IP:$DEST $(hostname)) $SRC) $TODAY)/'
			SYNCLINKDEST='rsync -e ssh $RSYNC_OPTS $EXCLUDE --link-dest=$LATEST $SRC/ $(catpath $(catpath $(catpath $USER@$IP:$DEST $(hostname)) $SRC) $TODAY)/'
			;;
		d)
			DEST=$OPTARG
			;;
		s)
			SRC=$(realpath $OPTARG)
			;;
		u)
			USER=$OPTARG
			;;
		i)
			IP=$OPTARG
			;;
		c)
			COMMAND=$OPTARG
			if [ ! -z "$COMMAND" ];
			then	
				COMMAND_COND=$(echo "$COMMAND" | cut -f 1 -d ';')
				case $COMMAND_COND in
					'done')
						ON_DONE_COMMAND="$(echo \"$COMMAND\" | cut -f 2 -d ';'); exit 0"
						;;
					"error")
						ON_ERROR_COMMAND="$(echo \"$COMMAND\" | cut -f 2 -d ';'); exit 1"
						;;
				esac
			fi
			;;
		e)
			EXCLUDE='EXCLUDE="--exclude-from=$(catpath $SRC '"$OPTARG)\"" #this neat little trick lets me avoid subshell bullshit
			;;
		C)
			RSYNC_OPTS="$RSYNC_OPTS -c"
			;;
		T)
			PRESERVE_TIMES=0
			;;
	esac
done

if [ "$PRESERVE_TIMES" = 1 ];
then
	RSYNC_OPTS="$RSYNC_OPTS -t "
fi

if [ "$REMOTE" = 1 ];
then
	DEST=$(ssh $USER@$IP realpath $DEST)
else
	DEST=$(realpath $DEST)
fi

if [ -z "$EXCLUDE" -a -f "$(catpath $SRC .exclude)" ];
then
	EXCLUDE='EXCLUDE="--exclude-from=$(catpath $SRC .exclude)"'
fi

function lsdest {
	LOC=$1	
	if [ ! -z "$LOC" ];
	then
		if [ "$REMOTE" = 1 ];
		then
			ssh $USER@$IP ls $(catpath $DEST $LOC)
		else
			ls $(catpath $(realpath $DEST) $LOC)
		fi
	else
		if [ "$REMOTE" = 1 ];
		then
			ssh $USER@$IP ls $DEST
		else
			ls $DEST
		fi
	fi
}

function mkdirdest {
	LOC=$1
	if [ ! -z "$LOC" ];
	then
		if [ "$REMOTE" = 1 ];
		then
			ssh $USER@$IP mkdir -p $(catpath $DEST $LOC)
		else
			mkdir -p $(catpath $DEST $LOC)
		fi
	else
		echo "error: mkdirdest called without argument" >&2
	fi
}

TODAY=$(date -u '+UTC%Y,%m,%d,%H%M')
if [ -z "$(lsdest | grep $(hostname))" ];
then
	mkdirdest $(hostname)
fi

LATEST=$(lsdest $(catpath $(hostname) $SRC) | egrep 'UTC[0-9]{4},[0-9]{2},[0-9]{2},[0-9]{4}' | sort -nr |  head -n 1 )
if [ ! -z "$LATEST" ];
then
	#LATEST="$(catpath $(catpath $DEST $(hostname)) $LATEST)"
	#LATEST="$(echo $LATEST | sed 's,//$,/,g' )/$(basename $SRC)"
	LATEST=$(catpath $DEST $(catpath $(catpath $(hostname) $SRC) $LATEST))
	mkdirdest $(catpath $(catpath $(hostname) $SRC) $TODAY)
	eval $EXCLUDE
	eval $SYNCLINKDEST  || $ON_ERROR_COMMAND
else
	mkdirdest $(catpath $(catpath $(hostname) $SRC) $TODAY)
	eval $EXCLUDE
	eval $SYNC  || $ON_ERROR_COMMAND
fi
eval $ON_DONE_COMMAND
